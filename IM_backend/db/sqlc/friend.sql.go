// Code generated by sqlc. DO NOT EDIT.
// source: friend.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const addFriend = `-- name: AddFriend :execresult
INSERT INTO friend (owner, friend_id) VALUES (?,?)
`

type AddFriendParams struct {
	Owner    int64 `json:"owner"`
	FriendID int64 `json:"friend_id"`
}

func (q *Queries) AddFriend(ctx context.Context, arg AddFriendParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, addFriend, arg.Owner, arg.FriendID)
}

const getOnesFriends = `-- name: GetOnesFriends :many
SELECT friend.id, owner, friend_id, friend.created_at, users.id, username, hashed_password, users.created_at 
FROM friend INNER JOIN users ON friend.friend_id = users.id 
WHERE owner = ?
LIMIT ?
OFFSET ?
`

type GetOnesFriendsParams struct {
	Owner  int64 `json:"owner"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetOnesFriendsRow struct {
	ID             int64     `json:"id"`
	Owner          int64     `json:"owner"`
	FriendID       int64     `json:"friend_id"`
	CreatedAt      time.Time `json:"created_at"`
	ID_2           int64     `json:"id_2"`
	Username       string    `json:"username"`
	HashedPassword string    `json:"hashed_password"`
	CreatedAt_2    time.Time `json:"created_at_2"`
}

func (q *Queries) GetOnesFriends(ctx context.Context, arg GetOnesFriendsParams) ([]GetOnesFriendsRow, error) {
	rows, err := q.db.QueryContext(ctx, getOnesFriends, arg.Owner, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOnesFriendsRow
	for rows.Next() {
		var i GetOnesFriendsRow
		if err := rows.Scan(
			&i.ID,
			&i.Owner,
			&i.FriendID,
			&i.CreatedAt,
			&i.ID_2,
			&i.Username,
			&i.HashedPassword,
			&i.CreatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
